"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var CssSyntaxError = require("./css-syntax-error");

// Recursivly clone objects
var clone = function (obj, parent) {
  if (typeof obj != "object") return obj;
  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) continue;
    var value = obj[i];

    if (i == "parent" && typeof value == "object") {
      if (parent) cloned[i] = parent;
    } else if (i == "source") {
      cloned[i] = value;
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (i) {
        return clone(i, cloned);
      });
    } else if (i != "before" && i != "after" && i != "between" && i != "semicolon") {
      cloned[i] = clone(value, cloned);
    }
  }

  return cloned;
};

// Some common methods for all CSS nodes
var Node = (function () {
  function Node() {
    var defaults = arguments[0] === undefined ? {} : arguments[0];
    for (var name in defaults) {
      this[name] = defaults[name];
    }
  }

  _prototypeProperties(Node, null, {
    error: {

      // Return error to mark error in your plugin syntax:
      //
      //   if ( wrongVariable ) {
      //       throw decl.error('Wrong variable');
      //   }
      //
      // You can also get origin line and column from previous source map:
      //
      //   if ( deprectedSyntax ) {
      //       var error = decl.error('Deprected syntax');
      //       console.warn(error.toString());
      //   }
      value: function error(message) {
        if (this.source) {
          var pos = this.source.start;
          return this.source.input.error(message, pos.line, pos.column);
        } else {
          return new CssSyntaxError(message);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    removeSelf: {

      // Remove this node from parent
      //
      //   decl.removeSelf();
      //
      // Note, that removing by index is faster:
      //
      //   rule.each( (decl, i) => rule.remove(i) );
      value: function removeSelf() {
        if (this.parent) {
          this.parent.remove(this);
        }
        this.parent = undefined;
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    replace: {

      // Shortcut to insert nodes before and remove self.
      //
      //   importNode.replace( loadedRoot );
      value: function replace(nodes) {
        this.parent.insertBefore(this, nodes);
        this.parent.remove(this);
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toString: {

      // Return CSS string of current node
      //
      //   decl.toString(); //=> "  color: black"
      value: function toString() {
        var result = "";
        var builder = function (str) {
          return result += str;
        };
        this.stringify(builder);
        return result;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    clone: {

      // Clone current node
      //
      //   rule.append( decl.clone() );
      //
      // You can override properties while cloning:
      //
      //   rule.append( decl.clone({ value: '0' }) );
      value: (function (_clone) {
        var _cloneWrapper = function clone() {
          return _clone.apply(this, arguments);
        };

        _cloneWrapper.toString = function () {
          return _clone.toString();
        };

        return _cloneWrapper;
      })(function () {
        var overrides = arguments[0] === undefined ? {} : arguments[0];
        var cloned = clone(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }),
      writable: true,
      enumerable: true,
      configurable: true
    },
    cloneBefore: {

      // Clone node and insert clone before current one.
      // It accept properties to change in clone and return new node.
      //
      //   decl.cloneBefore({ prop: '-webkit-' + del.prop });
      value: function cloneBefore() {
        var overrides = arguments[0] === undefined ? {} : arguments[0];
        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    cloneAfter: {

      // Clone node and insert clone after current one.
      // It accept properties to change in clone and return new node.
      //
      //   decl.cloneAfter({ value: convertToRem(decl.value) });
      value: function cloneAfter() {
        var overrides = arguments[0] === undefined ? {} : arguments[0];
        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    replaceWith: {

      // Replace with node by another one.
      //
      //   decl.replaceWith(fixedDecl);
      value: function replaceWith(node) {
        this.parent.insertBefore(this, node);
        this.removeSelf();
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    moveTo: {

      // Remove node from current place and put to end of new one.
      // It will also clean node code styles, but will keep `between` if old
      // parent and new parent has same root.
      //
      //   rule.moveTo(atRule);
      value: function moveTo(container) {
        this.cleanStyles(this.root() == container.root());
        this.removeSelf();
        container.append(this);
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    moveBefore: {

      // Remove node from current place and put to before other node.
      // It will also clean node code styles, but will keep `between` if old
      // parent and new parent has same root.
      //
      //   rule.moveBefore(rule.parent);
      value: function moveBefore(node) {
        this.cleanStyles(this.root() == node.root());
        this.removeSelf();
        node.parent.insertBefore(node, this);
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    moveAfter: {

      // Remove node from current place and put to after other node.
      // It will also clean node code styles, but will keep `between` if old
      // parent and new parent has same root.
      //
      //   rule.moveAfter(rule.parent);
      value: function moveAfter(node) {
        this.cleanStyles(this.root() == node.root());
        this.removeSelf();
        node.parent.insertAfter(node, this);
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    next: {

      // Return next node in parent. If current node is last one,
      // method will return `undefined`.
      //
      //   var next = decl.next();
      //   if ( next && next.prop == removePrefix(decl.prop) ) {
      //       decl.removeSelf();
      //   }
      value: function next() {
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    prev: {

      // Return previous node in parent. If current node is first one,
      // method will return `undefined`.
      //
      //   var prev = decl.prev();
      //   if ( prev && removePrefix(prev.prop) == decl.prop) ) {
      //       prev.removeSelf();
      //   }
      value: function prev() {
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toJSON: {

      // Remove `parent` node on cloning to fix circular structures
      value: function toJSON() {
        var fixed = {};

        for (var name in this) {
          if (!this.hasOwnProperty(name)) continue;
          if (name == "parent") continue;
          var value = this[name];

          if (value instanceof Array) {
            fixed[name] = value.map(function (i) {
              return typeof i == "object" && i.toJSON ? i.toJSON() : i;
            });
          } else if (typeof value == "object" && value.toJSON) {
            fixed[name] = value.toJSON();
          } else {
            fixed[name] = value;
          }
        }

        return fixed;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    style: {

      // Copy code style from first node with same type
      value: function style(own, detect) {
        var value;
        if (!detect) detect = own;

        // Already had
        if (own) {
          value = this[own];
          if (typeof value != "undefined") return value;
        }

        var parent = this.parent;

        // Hack for first rule in CSS
        if (detect == "before") {
          if (!parent || parent.type == "root" && parent.first == this) {
            return "";
          }
        }

        // Floating child without parent
        if (!parent) return this.defaultStyle[detect];

        // Detect style by other nodes
        var root = this.root();
        if (!root.styleCache) root.styleCache = {};
        if (typeof root.styleCache[detect] != "undefined") {
          return root.styleCache[detect];
        }

        if (detect == "semicolon") {
          root.eachInside(function (i) {
            if (i.nodes && i.nodes.length && i.last.type == "decl") {
              value = i.semicolon;
              if (typeof value != "undefined") return false;
            }
          });
        } else if (detect == "emptyBody") {
          root.eachInside(function (i) {
            if (i.nodes && i.nodes.length === 0) {
              value = i.after;
              if (typeof value != "undefined") return false;
            }
          });
        } else if (detect == "indent") {
          root.eachInside(function (i) {
            var p = i.parent;
            if (p != root && p.parent && p.parent == root) {
              if (typeof i.before != "undefined") {
                var parts = i.before.split("\n");
                value = parts[parts.length - 1];
                value = value.replace(/[^\s]/g, "");
                return false;
              }
            }
          });
        } else if (detect == "beforeComment") {
          root.eachComment(function (i) {
            if (typeof i.before != "undefined") {
              value = i.before;
              if (value.indexOf("\n") != -1) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value == "undefined") {
            value = this.style(null, "beforeDecl");
          }
        } else if (detect == "beforeDecl") {
          root.eachDecl(function (i) {
            if (typeof i.before != "undefined") {
              value = i.before;
              if (value.indexOf("\n") != -1) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value == "undefined") {
            value = this.style(null, "beforeRule");
          }
        } else if (detect == "beforeRule") {
          root.eachInside(function (i) {
            if (i.nodes && (i.parent != root || root.first != i)) {
              if (typeof i.before != "undefined") {
                value = i.before;
                if (value.indexOf("\n") != -1) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
        } else if (detect == "beforeClose") {
          root.eachInside(function (i) {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.after != "undefined") {
                value = i.after;
                if (value.indexOf("\n") != -1) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
        } else if (detect == "before" || detect == "after") {
          if (this.type == "decl") {
            value = this.style(null, "beforeDecl");
          } else if (this.type == "comment") {
            value = this.style(null, "beforeComment");
          } else if (detect == "before") {
            value = this.style(null, "beforeRule");
          } else {
            value = this.style(null, "beforeClose");
          }

          var node = this.parent;
          var depth = 0;
          while (node && node.type != "root") {
            depth += 1;
            node = node.parent;
          }

          if (value.indexOf("\n") != -1) {
            var indent = this.style(null, "indent");
            if (indent.length) {
              for (var step = 0; step < depth; step++) value += indent;
            }
          }

          return value;
        } else if (detect == "colon") {
          root.eachDecl(function (i) {
            if (typeof i.between != "undefined") {
              value = i.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
        } else if (detect == "beforeOpen") {
          root.eachInside(function (i) {
            if (i.type != "decl") {
              value = i.between;
              if (typeof value != "undefined") return false;
            }
          });
        } else {
          root.eachInside(function (i) {
            value = i[own];
            if (typeof value != "undefined") return false;
          });
        }

        if (typeof value == "undefined") value = this.defaultStyle[detect];

        root.styleCache[detect] = value;
        return value;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    root: {

      // Return top parent , parent of parents.
      value: function root() {
        var result = this;
        while (result.parent) result = result.parent;
        return result;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    cleanStyles: {

      // Recursivelly remove all code style properties (`before` and `between`).
      value: function cleanStyles(keepBetween) {
        delete this.before;
        delete this.after;
        if (!keepBetween) delete this.between;

        if (this.nodes) {
          for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].cleanStyles(keepBetween);
          }
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stringifyRaw: {

      // Use raw value if origin was not changed
      value: function stringifyRaw(prop) {
        var value = this[prop];
        var raw = this["_" + prop];
        if (raw && raw.value === value) {
          return raw.raw;
        } else {
          return value;
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Node;
})();

// Default code style
Node.prototype.defaultStyle = {
  colon: ": ",
  indent: "    ",
  beforeDecl: "\n",
  beforeRule: "\n",
  beforeOpen: " ",
  beforeClose: "\n",
  beforeComment: "\n",
  after: "\n",
  emptyBody: "",
  commentLeft: " ",
  commentRight: " "
};

module.exports = Node;